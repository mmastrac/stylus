<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Stylus Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Stylus Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="stylus-documentation-home"><a class="header" href="#stylus-documentation-home">Stylus Documentation Home</a></h1>
<p><strong>Stylus</strong> (<em>style + status</em>) is a lightweight status page for home
infrastructure. Configure a set of bash scripts that test the various parts of
your infrastructure, set up HTML/SVG with a diagram of your network, and stylus
will generate you a dynamic stylesheet to give you a visual overview of the
current state.</p>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<ul>
<li><a href="getting-started/overview.html">Getting Started</a></li>
<li><a href="configuration/server/README.html">Configuration</a></li>
<li><a href="examples/general/README.html">Examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>To begin, <em>Stylus</em> ships with a number of <a href="getting-started/examples/general/README.html">examples</a> that can be found in the <a href="https://github.com/mmastrac/stylus/archive/master.zip">source bundle</a>. Copy the <code>simple_network</code> folder to a location of your choice. In this guide we will assume that it will appear in <code>~/stylus/</code>.</p>
<p>Once you've got the example set up locally, we can walk though...</p>
<ul>
<li><a href="getting-started/running.html">Running Stylus</a></li>
<li><a href="getting-started/creating-project.html">Creating a Stylus Project</a></li>
<li><a href="getting-started/creating-monitors.html">Creating Monitors</a></li>
<li><a href="getting-started/creating-pages.html">Creating Monitor Pages</a></li>
<li><a href="getting-started/../configuration/server/README.html">Configuration</a></li>
<li><a href="getting-started/../configuration/advanced.html">Advanced Configuration</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>There are a number of options for running <em>Stylus</em>.</p>
<h3 id="docker"><a class="header" href="#docker">Docker</a></h3>
<p>The recommended option is to use Docker. A multi-arch Docker container is available under the repository <code>mmastrac/stylus</code> at https://hub.docker.com/r/mmastrac/stylus/.</p>
<p>Note that the container is hard-wired to run against a configuration file located in the container at <code>/srv/config.yaml</code>, and assumes that the remainder of the configuration is located in subdirectories of <code>/srv</code>.</p>
<pre><code class="language-bash"># Assume that this is running against the stylus example, this will map the example directory into
# the container's /srv folder. The container will automatically load config.yaml from this folder!
docker run --name stylus -p 8000:8000 -v ~/stylus/:/srv mmastrac/stylus:latest
</code></pre>
<h3 id="static-binaries"><a class="header" href="#static-binaries">Static Binaries</a></h3>
<p>If you would like to run it from a static binary, you may find a number of pre-built binary releases at https://github.com/mmastrac/stylus/releases.</p>
<pre><code class="language-bash"># This will run against the example in ~/stylus/
stylus_&lt;arch&gt; ~/stylus/config.yaml
</code></pre>
<h3 id="cargo"><a class="header" href="#cargo">Cargo</a></h3>
<p>For any platform where <code>cargo</code> is natively available, you can simply <code>cargo install</code> the <code>stylus</code> package.</p>
<pre><code class="language-bash">cargo install stylus
stylus ~/stylus/config.yaml
</code></pre>
<h3 id="from-source"><a class="header" href="#from-source">From Source</a></h3>
<p>If you have the source downloaded, you can run <code>stylus</code> directly from that source directory.</p>
<pre><code class="language-bash">cargo run -- ~/stylus/config.yaml
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-stylus-project"><a class="header" href="#creating-a-stylus-project">Creating a Stylus Project</a></h1>
<p>You can create a new stylus project by running the <code>stylus init</code> command. This
will create a new directory with a default configuration and a <code>monitor.d</code>
directory with a single monitor test.</p>
<pre><code class="language-bash session">$ stylus init ~/stylus
Initializing directory: "~/stylus"...
Done!

Run `stylus "~/stylus"` to start the server

$ tree ~/stylus/
  ├── config.yaml
  ├── monitor.d
  │   └── monitor
  │       ├── config.yaml
  │       └── test.sh
  └── static
      └── README.md
</code></pre>
<p>Once you've created the project, you can run the <code>stylus run</code> command to start
the server.</p>
<pre><code class="language-bash">stylus run ~/stylus
</code></pre>
<p>If you open your web browser to <code>http://localhost:8000</code>, you should see a
very basic default page with a green status:</p>
<blockquote>
<h1 id="stylus"><a class="header" href="#stylus">Stylus</a></h1>
<p>Updated at 2025-07-08T22:46:07.257Z</p>
<table style="border: 1px solid #ccc; border-collapse: collapse;">
    <tbody><tr>
        <th>Monitor</th>
        <th>Status</th>
        <th>Exit</th>
        <th>Log</th>
    </tr>
    <tr data-monitor-id="monitor" style="background-color: green;">
        <td>monitor</td>
        <td>green</td>
        <td>Success (0)</td>
        <td><a style="color: blue; text-decoration: underline;">Log</a></td>
    </tr>
</tbody></table>
<ul>
    <li><a style="color: blue; text-decoration: underline;">Status JSON</a></li>
    <li><a style="color: blue; text-decoration: underline;">Style CSS</a></li>
</ul>
</blockquote>
<p>By default, stylus will render a basic summary page for all of your monitors,
which allows you to work on your monitors before you've created any pages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-monitors"><a class="header" href="#creating-monitors">Creating Monitors</a></h1>
<p>A monitor is a script that is run periodically to check the status of a system.
Monitors are defined in the <code>monitor.d</code> directory in a <strong>Stylus</strong> project.</p>
<p>Monitors consist of a configuration file and a test script.</p>
<p>Using the project we created in the previous section, let's take a look at the
monitor that was created for us. The configuration from the initial project is:</p>
<pre><code class="language-bash session">$ cat ~/stylus/monitor.d/monitor/config.yaml
interval: 30s
timeout: 10s
command: test.sh

$ cat ~/stylus/monitor.d/monitor/test.sh
#!/bin/sh
echo 'Write your test script here'
</code></pre>
<p>The <code>interval</code> and <code>timeout</code> fields are used to control how often the monitor
is run and how long it is allowed to run for. The <code>command</code> field is the path
to the test script.</p>
<p>The test script is a simple shell script that will be run by the monitor.</p>
<p>To simplify development of monitors, stylus provides a <code>stylus test</code> command
that will run the test script and display the status of the monitor after it
completes.</p>
<pre><code class="language-bash session">$ stylus test ~/stylus/config.yaml --monitor monitor
Monitor Log
-----------

&lt;timestamp&gt; [exec  ] Starting
&lt;timestamp&gt; [stdout] Write your test script here
&lt;timestamp&gt; [exec  ] Termination: 0

State
-----

{
  "id": "monitor",
  "config": {
    "interval": "30s",
    "timeout": "10s",
    "command": "test.sh"
  },
  "status": {
    "status": "green",
    "code": 0,
    "description": "Success",
    "css": {
      "metadata": {}
    },
    "metadata": {},
    "log": [
      // ...
    ]
  },
  "children": {}
}

CSS
---

/* monitor */

/* Default rules */
[data-monitor-id="monitor"] {
  --monitor-id: "monitor";
  --monitor-status: green;
  --monitor-code: 0;
  --monitor-description: "Success";
}
</code></pre>
<p>Let's say that we want to change the test script to check if the server can see
the internet. We'll using <code>ping 8.8.8.8</code> as a proxy test for the internet
existing.</p>
<p>Let's update <code>test.sh</code> to:</p>
<pre><code class="language-bash">#!/bin/sh
ping -c 1 8.8.8.8
</code></pre>
<p>Now let's run the test again:</p>
<pre><code class="language-bash session">$ stylus test ~/stylus/config.yaml monitor
Monitor Log
-----------

&lt;timestamp&gt; [exec  ] Starting
&lt;timestamp&gt; [stdout] PING 8.8.8.8 (8.8.8.8): 56 data bytes
&lt;timestamp&gt; [stdout] 64 bytes from 8.8.8.8: icmp_seq=0 ttl=111 time=20.496 ms
&lt;timestamp&gt; [stdout] 
&lt;timestamp&gt; [stdout] --- 8.8.8.8 ping statistics ---
&lt;timestamp&gt; [stdout] 1 packets transmitted, 1 packets received, 0.0% packet loss
&lt;timestamp&gt; [stdout] round-trip min/avg/max/stddev = 20.496/20.496/20.496/0.000 ms
&lt;timestamp&gt; [exec  ] Termination: 0

...
</code></pre>
<p>As expected, the monitor successfully pings the internet.</p>
<h2 id="more-complex-monitors"><a class="header" href="#more-complex-monitors">More Complex Monitors</a></h2>
<p>Monitors can be as simple or complex as you need them to be. For example, if
you want to check the status of a service, you can use a monitor to check if
the service is running.</p>
<p>Note that in the below examples, we're using the <code>STYLUS_MONITOR_ID</code> environment
variable to identify the monitor. This is a special variable that is set by
<strong>Stylus</strong> to the monitor's ID.</p>
<pre><code class="language-bash">#!/bin/sh
set -xeuf -o pipefail
# Check the health of a service running on the monitor
curl --fail http://$STYLUS_MONITOR_ID:8080/health | jq --raw-output '.status'
</code></pre>
<p>You can use <a href="https://en.wikipedia.org/wiki/Simple_Network_Management_Protocol">SNMP</a>
to check the status of a network device.</p>
<pre><code class="language-bash">#!/bin/sh
set -xeuf -o pipefail
# Print the SNMP OID for the system description
snmpwalk -v 2c -c public $STYLUS_MONITOR_ID 1.3.6.1.2.1.1.1.0
# Print the SNMP OID for the system uptime
snmpwalk -v 2c -c public $STYLUS_MONITOR_ID 1.3.6.1.2.1.1.3.0
</code></pre>
<p>For more information on complex monitors, see the <a href="getting-started/../examples/">examples</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-monitor-pages"><a class="header" href="#creating-monitor-pages">Creating Monitor Pages</a></h1>
<p><strong>Stylus</strong> is designed to be flexible and gives you a lot (too much?) freedom in
how you configure your display.</p>
<h2 id="rendering-technologies"><a class="header" href="#rendering-technologies">Rendering Technologies</a></h2>
<p><strong>Stylus</strong> works particularly well with
<a href="https://en.wikipedia.org/wiki/Scalable_Vector_Graphics">SVG</a> diagrams, but can
use any markup language that supports either CSS or dynamic updates via JSON
data (eg: <a href="https://angular.io/">Angular</a>, <a href="https://reactjs.org/">React</a>, etc).</p>
<h3 id="html"><a class="header" href="#html">HTML</a></h3>
<p>React is a popular library for building user interfaces. Using <code>/status.json</code>
as the data source, you can create a simple page with the current state of the
monitors.</p>
<p>The <a href="https://isoflow.io">IsoFlow</a> component for React allows you to load a model
and render it as an isometric diagram with a little bit of glue in <strong>Stylus</strong>:</p>
<p><img src="getting-started/isoflow.png" alt="IsoFlow" /></p>
<h3 id="svg"><a class="header" href="#svg">SVG</a></h3>
<p>SVG is a flexible image format that conveniently supports CSS styling. See the
<a href="getting-started/../tutorials/svg-diagrams.html">SVG tutorial</a> for more details on building a
diagram using <a href="https://app.diagrams.net/">diagrams.net</a>.</p>
<p><a href="https://d3js.org/">d3.js</a> is a popular library for creating interactive
diagrams. See the <a href="https://github.com/mmastrac/stylus/tree/master/examples/d3"><code>d3.js</code> example in the
repository</a> for an
example of how to use it with <strong>Stylus</strong>.</p>
<h2 id="hooks-and-endpoints"><a class="header" href="#hooks-and-endpoints">Hooks and Endpoints</a></h2>
<p>There are number of provided hooks for updating status, and depending on which
technology you'd like to use for your status page, you can choose which one
makes sense.</p>
<p>Monitors are independent of the the technology you use to render your page, so
you can start with a very basic page and then add more complexity as you go.</p>
<h2 id="css"><a class="header" href="#css">CSS</a></h2>
<p>The simplest way to create a monitoring page is to use CSS to update the
status of the page.</p>
<p>The <code>/style.css</code> route serves live CSS with the current state of the monitors.</p>
<p>For each monitor, <strong>Stylus</strong> will generate a CSS block with the current state of
the monitor as CSS variables (including any metadata your script has generated):</p>
<pre><code class="language-css">[data-monitor-id="web-server-1"] {
  --monitor-id: "web-server-1";
  --monitor-status: green;
  --monitor-code: 0;
  --monitor-description: "Success";
  --monitor-metadata-rps: RPS: 702;
}
</code></pre>
<p>These CSS variables can be used for basic styling of the page, but it is highly
recommended to generate more complex CSS rules to style the page.</p>
<p>In your project's <code>config.yaml</code> file, you can specify a number of rules to
style the page. For each rules in this section, a CSS block will be generated
for each monitor.</p>
<p>For example, adding these rules:</p>
<pre><code class="language-yaml">  # Specify a number of rules - selector/declaration pairs. Each pair will generate a CSS block.
  rules:
    # Style the HTML/SVG with the appropriate status color
    - selectors: |
        #{{monitor.id}},
        [data-monitor-id="{{monitor.id}}"] &gt; *
      declarations: |
        background-color: {{monitor.status.css.metadata.color}} !important;
        fill: {{monitor.status.css.metadata.color}} !important;
</code></pre>
<p>... will generate the following CSS block for each monitor:</p>
<pre><code class="language-css">/* web-server-1 */

/* Default rules */
[data-monitor-id="web-server-1"] {
  --monitor-id: "web-server-1";
  --monitor-status: green;
  --monitor-code: 0;
  --monitor-description: "Success";
  --monitor-metadata-rps: RPS: 702;
}
#web-server-1, [data-monitor-id="web-server-1"] {
    background-color: #d0e6a5 !important;
    fill: #d0e6a5 !important;
}
</code></pre>
<p>See the <a href="getting-started/../configuration/css/">CSS Configuration</a> section for more details.</p>
<h2 id="json"><a class="header" href="#json">JSON</a></h2>
<p>The <code>/status.json</code> route serves the current state of the monitors as JSON.</p>
<p>This can be used for dynamic rendering of the page, or for updating the page
with a script.</p>
<p>Each monitor's latest status is available in the JSON response, along with its
log output, and any metadata generated by the monitor script.</p>
<pre><code class="language-json">{
    "id": "database",
    "config": {
        "interval": "5s",
        "timeout": "15s",
        "command": "..."
    },
    "status": {
        "status": "green",
        "code": 0,
        "description": "Success",
        "css": {
            "metadata": {
                "color": "#d0e6a5"
            }
        },
        "metadata": {},
        "log": [
            "2025-07-08T23:51:05.732946+00:00 [exec  ] Starting",
            "..."
        ]
    },
    "children": {}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="server-configuration"><a class="header" href="#server-configuration">Server Configuration</a></h1>
<p>The server configuration is stored in <code>config.yaml</code> in the root directory of the configuration. This controls the overall server behaviour (including listening ports) and points <em>Stylus</em> to the monitoring directory (<code>monitor.d</code> by default).</p>
<pre><code class="language-yaml"># Stylus will fail to load any configuration without a version of 1 (for future extensibility)
version: 1

# HTTP server configuration
server:
  # Listen port
  port: 8000
  # Static file directory
  static: static

# Monitor configuration
monitor:
  # The top-level directory that stylus looks for monitor directories
  dir: monitor.d

css:
  # Arbitrary metadata can be associated with each of the four states: blank (no state),
  # red (failed), yellow (timed out) or green (success).

  # Use metadata to get prettier colors - note that we can add arbitrary string keys and values here
  metadata:
    blank:
      color: "white"
    red:
      color: "#fa897b"
    yellow:
      color: "#ffdd94"
    green:
      color: "#d0e6a5"

  # Specify a number of rules - selector/declaration pairs. Each pair will generate a CSS block.
  rules:
    # Style the HTML/SVG with the appropriate status color
    - selectors: "
        #{{monitor.id}},
        [data-monitor-id=\"{{monitor.id}}\"] &gt; *
      "
      declarations: "
        background-color: {{monitor.status.css.metadata.color}} !important;
        fill: {{monitor.status.css.metadata.color}} !important;
      "
    # Add some text for the status/return value of the script
    - selectors: "
        #{{monitor.id}} td:nth-child(2)::after
      "
      declarations: "
        content: \"status={{monitor.status.status}} retval={{monitor.status.code}}\"
      "

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="css-configuration"><a class="header" href="#css-configuration">CSS Configuration</a></h1>
<p>The CSS configuration controls how Stylus generates dynamic stylesheets based on monitor status. This includes metadata for different states and CSS rules for styling your HTML/SVG elements.</p>
<pre><code class="language-yaml"># config.yaml
# version: 1
# server: ...
# monitor: ...

css:
  # Arbitrary metadata can be associated with each of the four states: blank (no state),
  # red (failed), yellow (timed out) or green (success).

  # Use metadata to get prettier colors - note that we can add arbitrary string keys and values here
  metadata:
    blank:
      color: "white"
    red:
      color: "#fa897b"
    yellow:
      color: "#ffdd94"
    green:
      color: "#d0e6a5"

  # Specify a number of rules - selector/declaration pairs. Each pair will generate a CSS block.
  rules:
    # Style the HTML/SVG with the appropriate status color
    - selectors: "
        #{{monitor.id}},
        [data-monitor-id=\"{{monitor.id}}\"] &gt; *
      "
      declarations: "
        background-color: {{monitor.status.css.metadata.color}} !important;
        fill: {{monitor.status.css.metadata.color}} !important;
      "
    # Add some text for the status/return value of the script
    - selectors: "
        #{{monitor.id}} td:nth-child(2)::after
      "
      declarations: "
        content: \"status={{monitor.status.status}} retval={{monitor.status.code}}\"
      "
</code></pre>
<h2 id="css-interpolation"><a class="header" href="#css-interpolation">CSS Interpolation</a></h2>
<p>Interpolation is used in the <code>css</code> block to control the display. The interpolation library under the hood is <a href="https://github.com/sunng87/handlebars-rust">handlebars-rust</a> and any of the advanced syntaxes may be used.</p>
<p>Generally a monitor's output is interpolated from its status JSON, which will have a following form like the given example below:</p>
<pre><code class="language-json">{
  "id": "my-id",
  "config": {
    "interval": "1m",
    "timeout": "30s",
    "command": "/full/path/to/test.sh"
  },
  "status": {
    "status": "green",
    "code": 0,
    "description": "Success",
    "css": {
      "metadata": {
        "color": "#d0e6a5"
      }
    },
    "metadata": {
      "key": "value1"
    }
  }
}
</code></pre>
<p>The root object is named <code>monitor</code>, and you may choose to use any of the keys as such:</p>
<pre><code>{{monitor.id}} = my-id
{{monitor.status.status}} = green
{{monitor.status.css.metadata.color}} = #d0e6a5
{{monitor.status.metadata.key}} = value1
</code></pre>
<p>You may use additional text content around the interpolation blocks. For example, <code>background-color: {{monitor.status.css.metadata.color}} !important;</code> will interpolate to <code>background-color: #d0e6a5 !important</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monitor-configuration"><a class="header" href="#monitor-configuration">Monitor Configuration</a></h1>
<p>Monitor configurations define how Stylus tests your infrastructure components. Each monitor consists of a test script that runs on a schedule and reports the status back to Stylus.</p>
<h2 id="standard-monitor"><a class="header" href="#standard-monitor">Standard Monitor</a></h2>
<p>A standard monitor consists of a single test for a single host.</p>
<pre><code class="language-yaml">test:
  # (optional) The internal ID to use for this test. If omitted, the ID is inferred from the monitor directory's name.
  id: foo
  # How often the test is run. The interval restarts from the last success or failure of the test.
  interval: 60s
  # How long the script will be given to run before it is killed.
  timeout: 30s
  # The test command to run, relative to the monitor directory. The PATH is not used and the file must be
  # directly executable.
  command: test.sh
</code></pre>
<h2 id="monitor-states"><a class="header" href="#monitor-states">Monitor States</a></h2>
<p>Output from the test's standard output and standard error streams are captured and available from the logging endpoint.</p>
<ul>
<li><strong>Blank</strong>: A test that has not run or completed yet</li>
<li><strong>Yellow</strong>: A test that has timed out</li>
<li><strong>Red</strong>: Tests that fail by returning a value other than zero</li>
<li><strong>Green</strong>: Tests that return zero (success)</li>
</ul>
<h2 id="group-monitor"><a class="header" href="#group-monitor">Group Monitor</a></h2>
<p>A group may be configured such that a single script may update states for multiple monitors. See <a href="configuration/monitor/../advanced.html">Advanced Configuration</a> for examples of configuring such a group monitor.</p>
<h2 id="testing-your-configurations"><a class="header" href="#testing-your-configurations">Testing Your Configurations</a></h2>
<p>As monitor scripts using metadata can be somewhat tricky to get right, <em>Stylus</em> includes a <code>--test</code> command-line argument to allow you to develop your test script in a slightly more interactive manner. The output from <code>--test</code> will include the test script's stdout and stderr streams, plus the parsed monitor state as JSON, and the final rendered CSS.</p>
<p>Tests scripts may also set metadata associated with the run. More information on this is available in <a href="configuration/monitor/../advanced.html">Advanced Configuration</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-configuration"><a class="header" href="#advanced-configuration">Advanced Configuration</a></h1>
<h2 id="group-monitors"><a class="header" href="#group-monitors">Group Monitors</a></h2>
<p>A group monitor allows a single test script's execution to update the state for
multiple entities. For example, you may be able to scrape the state of multiple
hosts from a single controller, or you may want to monitor the state of multiple
ports on a single switch.</p>
<pre><code class="language-yaml">group:
    # The ID pattern for this group. This ID must use interpolation from axis values to generate a set of
    # globally unique IDs. 
    id: port-{{ index }}

    # The configuration axes.
    axes:
        # The Axis name and a list of values
        - name: index
          values: [0, 1, 2, 3, 4, 5, 6, 7]

    # A standard monitor configuration (see the Standard Monitor description)
    test:
        interval: 60s
        timeout: 30s
        command: test.sh
</code></pre>
<p>The group's test script is unique in that it must output state-modifying commands to its standard output. Each
of these state-modifying commands starts with the prefix <code>@@STYLUS@@</code>.</p>
<pre><code class="language-bash">echo '@@STYLUS@@ group.port-0.status.status="yellow"'
echo '@@STYLUS@@ group.port-1.status.status="green"'
echo '@@STYLUS@@ group.port-2.status.status="yellow"'
echo '@@STYLUS@@ group.port-3.status.status="green"'
echo '@@STYLUS@@ group.port-4.status.status="green"'
echo '@@STYLUS@@ group.port-5.status.status="yellow"'
echo '@@STYLUS@@ group.port-6.status.status="yellow"'
echo '@@STYLUS@@ group.port-7.status.status="red"'
</code></pre>
<h2 id="metadata"><a class="header" href="#metadata">Metadata</a></h2>
<p>A test script may update metadata for the monitor, including the built-in status and description fields. These commands start with the prefix <code>@@STYLUS@@</code> and may be output to standard output or standard error.</p>
<p>An example of metadata update commands is shown below:</p>
<pre><code>echo '@@STYLUS@@ status.description="Custom (yellow)"'
echo '@@STYLUS@@ status.status="yellow"'
echo '@@STYLUS@@ status.metadata.key="value1"'
</code></pre>
<p>These may be referenced via standard interpolation, such as <code>{{monitor.status.metadata.key}}</code>.</p>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment variables</a></h2>
<p><em>Stylus</em> invokes all test scripts with a special environment variable named <code>STYLUS_MONITOR_ID</code>. This may be used
as a convenient way to test multiple monitors using shared scripts. For example, a test script may be configured
like so:</p>
<pre><code class="language-bash">ssh $STYLUS_MONITOR_ID my-test-command
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-tips"><a class="header" href="#general-tips">General Tips</a></h1>
<p>There are several approaches you can take to monitoring with Stylus. This
section covers general best practices and tips for writing effective monitor
scripts.</p>
<h2 id="safe-scripting"><a class="header" href="#safe-scripting">Safe Scripting</a></h2>
<p>Because monitor scripts may have a large number of moving parts, consider using
<a href="https://sipb.mit.edu/doc/safe-shell/">safe shell scripting</a> techniques to
ensure that any failure of any kind will return an error code.</p>
<p>In addition <code>set -x</code> can be useful to print all commands that run as part of a
monitor script. These are available in the logging endpoints and will show you
the expansion of environment variables.</p>
<pre><code class="language-bash">#!/bin/bash
set -xeuf -o pipefail
</code></pre>
<h2 id="testing-your-configurations-1"><a class="header" href="#testing-your-configurations-1">Testing Your Configurations</a></h2>
<p>As monitor scripts using metadata can be somewhat tricky to get right, <em>Stylus</em>
includes a <code>test</code> command-line argument to allow you to develop your test
script in a slightly more interactive manner. The output from <code>test</code> will
include the test script's stdout and stderr streams, plus the parsed monitor
state as JSON, and the final rendered CSS.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>See example configurations and use cases for Stylus.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ping-monitoring"><a class="header" href="#ping-monitoring">Ping Monitoring</a></h1>
<p>The simplest monitor is a ping script. One ping is usually enough for most cases. You can pass a timeout to ping, but <em>Stylus</em> will automatically kill processes if they run too long.</p>
<h2 id="basic-ping-script"><a class="header" href="#basic-ping-script">Basic Ping Script</a></h2>
<pre><code class="language-bash">#!/bin/bash
ping -c 1 ${STYLUS_MONITOR_ID}
</code></pre>
<h2 id="ping-with-custom-host"><a class="header" href="#ping-with-custom-host">Ping with Custom Host</a></h2>
<pre><code class="language-bash">#!/bin/bash
ping -c 1 8.8.8.8
</code></pre>
<h2 id="ping-with-timeout"><a class="header" href="#ping-with-timeout">Ping with Timeout</a></h2>
<pre><code class="language-bash">#!/bin/bash
ping -c 1 -W 5 ${STYLUS_MONITOR_ID}
</code></pre>
<h2 id="when-to-use-ping"><a class="header" href="#when-to-use-ping">When to Use Ping</a></h2>
<p>Ping monitoring is ideal for:</p>
<ul>
<li>Basic connectivity testing</li>
<li>Simple network reachability checks</li>
<li>Quick health checks for network devices</li>
<li>Testing internet connectivity</li>
</ul>
<p>For more complex monitoring scenarios, consider using <a href="examples/ping/../ssh/">SSH</a>, <a href="examples/ping/../snmp/">SNMP</a>, or <a href="examples/ping/../scraping/">HTML/API scraping</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ssh-monitoring"><a class="header" href="#ssh-monitoring">SSH Monitoring</a></h1>
<p>SSH monitoring allows you to execute commands on remote systems and check their status. This is useful for monitoring servers, network devices, and other systems that support SSH access.</p>
<h2 id="ssh-configuration"><a class="header" href="#ssh-configuration">SSH Configuration</a></h2>
<p>To make your life easier, you can collect all of your SSH credentials in <a href="https://www.ssh.com/ssh/config/">a configuration file</a>. The examples in this section will assume you've got a central SSH configuration file.</p>
<pre><code>host pi-*
	User matt
host tower
	User root
host unifi-*
	User admin
host *
	IdentityFile /srv/ssh_id_rsa
</code></pre>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<p>Depending on your security requirements, you may wish to loosen some of your SSH client's security check requirements. By disabling strict host key checking and host IP checking, your monitors will be more reliable but there will be <a href="https://security.stackexchange.com/questions/161520/what-is-the-actual-drawback-of-checkhostip-no">some tradeoffs</a>.</p>
<pre><code class="language-bash">ssh &lt;...&gt; -oStrictHostKeyChecking=no -oCheckHostIP=no
</code></pre>
<h2 id="basic-ssh-check"><a class="header" href="#basic-ssh-check">Basic SSH Check</a></h2>
<pre><code class="language-bash"># Assumes that `ssh_config` lives in the same folder as this script 
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &gt;/dev/null 2&gt;&amp;1 &amp;&amp; pwd )"
SSH_CONFIG=$DIR/ssh_config

ssh_check () {
    local host="$STYLUS_MONITOR_ID"
    ssh -F $SSH_CONFIG $host -oStrictHostKeyChecking=no -oCheckHostIP=no "true"
}

ssh_check
</code></pre>
<h2 id="ssh--gather-basic-hardware-info"><a class="header" href="#ssh--gather-basic-hardware-info">SSH + Gather Basic Hardware Info</a></h2>
<pre><code class="language-bash"># Assumes that `ssh_config` lives in the same folder as this script 
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &gt;/dev/null 2&gt;&amp;1 &amp;&amp; pwd )"
SSH_CONFIG=$DIR/ssh_config

ssh_check () {
    local host="$STYLUS_MONITOR_ID"
    ssh -F $SSH_CONFIG $host -oStrictHostKeyChecking=no -oCheckHostIP=no \
        "uname -a &amp;&amp; uptime &amp;&amp; cat /proc/cpuinfo | grep -i -E '(hardware|model|stepping|revision)' | sort | uniq"
}

ssh_check
</code></pre>
<h2 id="when-to-use-ssh"><a class="header" href="#when-to-use-ssh">When to Use SSH</a></h2>
<p>SSH monitoring is ideal for:</p>
<ul>
<li>Server health checks</li>
<li>Remote system monitoring</li>
<li>Custom command execution</li>
<li>Gathering system information</li>
<li>Service status checks</li>
</ul>
<p>For simpler connectivity tests, consider <a href="examples/ssh/../ping/">ping monitoring</a>. For network devices, consider <a href="examples/ssh/../snmp/">SNMP monitoring</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="snmp-monitoring"><a class="header" href="#snmp-monitoring">SNMP Monitoring</a></h1>
<p>SNMP (Simple Network Management Protocol) is a useful way to write more complex checks for network devices, but the output of the tools requires some massaging.</p>
<h2 id="basic-snmp-check"><a class="header" href="#basic-snmp-check">Basic SNMP Check</a></h2>
<pre><code class="language-bash">snmp_check () {
    local host="$STYLUS_MONITOR_ID"
    ARR=`snmpbulkwalk -OsQ -c public $host ifTable`
    jq -n --arg inarr "${ARR}" '[$inarr | split("\n")
        | .[]
        | capture("(?&lt;key&gt;[^\\.]+)\\.(?&lt;idx&gt;\\d+)\\s+=\\s+(?&lt;value&gt;.*)")
    ] | group_by(.idx) | .[] | from_entries'
}

# Some legacy devices only respond to SNMP v1
snmp_v1_check () {
    local host="$STYLUS_MONITOR_ID"
    ARR=`snmpwalk -v1 -OsQ -c public $host ifTable`
    jq -n --arg inarr "${ARR}" '[$inarr | split("\n")
        | .[]
        | capture("(?&lt;key&gt;[^\\.]+)\\.(?&lt;idx&gt;\\d+)\\s+=\\s+(?&lt;value&gt;.*)")
    ] | group_by(.idx) | .[] | from_entries'
}

snmp_parse () {
    cat - | jq -r '
        # Only parse ethernet ports and omit anything that looks like a vlan port (ending with a .xxxx)
        select(.ifType=="ethernetCsmacd" and (.ifDescr | test("\\.\\d+$") | not)) 
        | "@@STYLUS@@ group.'$STYLUS_MONITOR_ID'-" 
            + .ifIndex 
            + ".status.status=" 
            + (if .ifOperStatus == "up" then "\"green\"" else "\"blank\"" end)' 
}

# Map the SNMP JSON output to @@STYLUS@@ metadata updates
snmp_check | snmp_parse
</code></pre>
<h2 id="when-to-use-snmp"><a class="header" href="#when-to-use-snmp">When to Use SNMP</a></h2>
<p>SNMP monitoring is ideal for:</p>
<ul>
<li>Network device monitoring (switches, routers, etc.)</li>
<li>Interface status monitoring</li>
<li>Network performance metrics</li>
<li>Device health checks</li>
<li>Legacy network equipment</li>
</ul>
<p>For simpler connectivity tests, consider <a href="examples/snmp/../ping/">ping monitoring</a>. For server monitoring, consider <a href="examples/snmp/../ssh/">SSH monitoring</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="htmlapi-scraping"><a class="header" href="#htmlapi-scraping">HTML/API Scraping</a></h1>
<p>Some devices can be tested using a simple cURL script, while others require more complex HTML parsing and API interaction.</p>
<h2 id="simple-curl-check"><a class="header" href="#simple-curl-check">Simple cURL Check</a></h2>
<pre><code class="language-bash">curl --silent --max-time 2 &lt;url&gt;
</code></pre>
<h2 id="html-scraping-with-pup-and-jq"><a class="header" href="#html-scraping-with-pup-and-jq">HTML Scraping with pup and jq</a></h2>
<p>In other cases you may want to scrape HTML. The <code>pup</code> tool is included in the docker image to make this easier. You can use the <code>json{}</code> filter to pass a pre-processed HTML DOM tree to <code>jq</code> for further processing.</p>
<p>This example scrapes the power state from a Web Power Switch 7:</p>
<pre><code class="language-bash">#!/bin/bash
set -euf -o pipefail

function fetch() {
    curl --silent --max-time 2 --basic -u &lt;credentials&gt; &lt;url&gt; \
        | pup -c "table table tr[bgcolor=#F4F4F4] json{}" \
        | jq "[.[] | [.children | .. | .text? | select(. != null)] | { \"name\": .[1], \"state\": (.[2]==\"ON\") }]"
}

n=0
until [ "$n" -ge 10 ]
do
   HTML=`fetch` &amp;&amp; break
   n=$((n+1)) 
done

echo $HTML | \
    jq -r -e ". | to_entries | .[] | \"@@STYLUS@@ group.power-\" + (.key + 1 | tostring) + \".status.status=\" + if .value.state then \"\\\"green\\\"\" else \"\\\"blank\\\"\" end"
</code></pre>
<h2 id="when-to-use-scraping"><a class="header" href="#when-to-use-scraping">When to Use Scraping</a></h2>
<p>HTML/API scraping is ideal for:</p>
<ul>
<li>Web-based device monitoring</li>
<li>API endpoint health checks</li>
<li>Web application monitoring</li>
<li>Devices with web interfaces</li>
<li>Custom dashboard monitoring</li>
</ul>
<p>For simpler connectivity tests, consider <a href="examples/scraping/../ping/">ping monitoring</a>. For server monitoring, consider <a href="examples/scraping/../ssh/">SSH monitoring</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="svg-1"><a class="header" href="#svg-1">SVG</a></h1>
<p>Short story: Using a tool like <a href="https://app.diagrams.net/?splash=0&amp;p=svgdata">diagrams.net</a>, create an SVG diagram of your network. Attach an SVG DOM attribute to the elements you'd like to style with status changes. If you're using <a href="https://app.diagrams.net/?splash=0&amp;p=svgdata">diagrams.net</a>, this can be done using the <code>svgdata</code> plugin. Alternatively, you can use the automatic identifiers generated by your SVG editor as your monitoring identifiers.</p>
<p>From the SVG you've generated, create CSS selectors and rules that will apply
styles to the appropriate elements as statuses change. The SVG <code>fill</code> attribute
is a good candidate to change, but ensure that you're using <code>!important</code> on all
your rules to override the fill colors created by your SVG editor.</p>
<h2 id="detailed-guide"><a class="header" href="#detailed-guide">Detailed guide</a></h2>
<p>Enable one of the networking diagram sets on <a href="https://app.diagrams.net/?splash=0&amp;p=svgdata">diagrams.net</a> that matches the style of diagram you'd like to create.</p>
<p><img src="https://raw.githubusercontent.com/mmastrac/stylus/master/docs/svg-demo/screen-1.png" alt="" /></p>
<p>For each of the networking elements you've dropped on the canvas, click the "edit data" button to add metadata.</p>
<p><img src="https://raw.githubusercontent.com/mmastrac/stylus/master/docs/svg-demo/screen-2.png" alt="" /></p>
<p>Set a custom property named <code>infra-id</code>. This will be the ID we'll later use to configure the diagram.</p>
<p><img src="https://raw.githubusercontent.com/mmastrac/stylus/master/docs/svg-demo/screen-3.png" alt="" /></p>
<p>Once you've completed your diagram, export it as an SVG.</p>
<p><img src="https://raw.githubusercontent.com/mmastrac/stylus/master/docs/svg-demo/screen-4.png" alt="" /></p>
<p>These are the recommended options you can use to create a standalone SVG file.</p>
<p><img src="https://raw.githubusercontent.com/mmastrac/stylus/master/docs/svg-demo/screen-5.png" alt="" /></p>
<p>The final result.</p>
<p><img src="https://raw.githubusercontent.com/mmastrac/stylus/master/docs/svg-demo/example.svg" alt="" /></p>
<p>And the final SVG source:</p>
<pre><code class="language-svg">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;
&lt;svg xmlns="http://www.w3.org/2000/svg" style="background-color: rgb(255, 255, 255);" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="181" height="167" viewBox="-0.5 -0.5 181 167"&gt;
&lt;defs&gt;
&lt;filter id="dropShadow"&gt;
&lt;feGaussianBlur in="SourceAlpha" stdDeviation="1.7" result="blur"/&gt;
&lt;feOffset in="blur" dx="3" dy="3" result="offsetBlur"/&gt;
&lt;feFlood flood-color="#3D4574" flood-opacity="0.4" result="offsetColor"/&gt;
&lt;feComposite in="offsetColor" in2="offsetBlur" operator="in" result="offsetBlur"/&gt;
&lt;feBlend in="SourceGraphic" in2="offsetBlur"/&gt;
&lt;/filter&gt;
&lt;/defs&gt;
&lt;g filter="url(#dropShadow)"&gt;
&lt;g id="cell-f1RpjmRWZniSFc_S4n2y-1" content="&amp;lt;object label=&amp;quot;&amp;quot; infra-id=&amp;quot;firewall&amp;quot;/&amp;gt;" data-label="" data-infra-id="firewall"&gt;
&lt;rect x="0" y="20" width="50" height="44" fill="none" stroke="none" pointer-events="all"/&gt;&lt;path d="M 0 64 L 0 54.01 L 23.64 54.01 L 23.64 64 Z M 25 54.01 L 50 54.01 L 50 64 L 25 64 Z M 37.5 52.75 L 37.5 42.71 L 50 42.71 L 50 52.75 Z M 36.04 42.71 L 36.04 52.75 L 13.91 52.75 L 13.91 42.71 Z M 12.55 52.75 L 0 52.75 L 0 42.66 L 12.55 42.66 Z M 23.59 41.44 L 0 41.44 L 0 31.4 L 23.59 31.4 Z M 25 31.4 L 50 31.4 L 50 41.44 L 25.1 41.44 Z M 37.5 30.09 L 37.5 20 L 50 20 L 50 30.09 Z M 36.04 20.05 L 36.04 30.09 L 13.91 30.09 L 13.91 20.05 Z M 12.45 30.09 L 0 30.09 L 0 20.05 L 12.45 20.05 Z" fill="#00188d" stroke="none" pointer-events="all"/&gt;&lt;/g&gt;&lt;g id="cell-f1RpjmRWZniSFc_S4n2y-3" content="&amp;lt;object label=&amp;quot;&amp;quot; infra-id=&amp;quot;server-a&amp;quot;/&amp;gt;" data-label="" data-infra-id="server-a"&gt;&lt;rect x="140" y="0" width="24" height="50" fill="none" stroke="none" pointer-events="all"/&gt;
&lt;path d="M 140 50 L 140 2.51 C 140 1.12 141.11 0 142.47 0 L 161.53 0 C 162.89 0 164 1.12 164 2.51 L 164 50 Z M 143.6 45.08 L 160.4 45.08 L 160.4 42.67 L 143.6 42.67 Z M 160.4 40.26 L 160.4 37.8 L 143.6 37.8 L 143.6 40.26 Z M 143.6 9.79 L 160.4 9.79 L 160.4 7.33 L 143.6 7.33 Z" fill="#00188d" stroke="none" pointer-events="all"/&gt;
&lt;/g&gt;
&lt;g id="cell-f1RpjmRWZniSFc_S4n2y-4" content="&amp;lt;object label=&amp;quot;&amp;quot; infra-id=&amp;quot;server-c&amp;quot;/&amp;gt;" data-label="" data-infra-id="server-c"&gt;
&lt;rect x="90" y="110" width="24" height="50" fill="none" stroke="none" pointer-events="all"/&gt;
&lt;path d="M 90 160 L 90 112.51 C 90 111.12 91.11 110 92.47 110 L 111.53 110 C 112.89 110 114 111.12 114 112.51 L 114 160 Z M 93.6 155.08 L 110.4 155.08 L 110.4 152.67 L 93.6 152.67 Z M 110.4 150.26 L 110.4 147.8 L 93.6 147.8 L 93.6 150.26 Z M 93.6 119.79 L 110.4 119.79 L 110.4 117.33 L 93.6 117.33 Z" fill="#00188d" stroke="none" pointer-events="all"/&gt;
&lt;/g&gt;
&lt;g id="cell-f1RpjmRWZniSFc_S4n2y-5" content="&amp;lt;object label=&amp;quot;&amp;quot; infra-id=&amp;quot;server-b&amp;quot;/&amp;gt;" data-label="" data-infra-id="server-b"&gt;
&lt;rect x="150" y="80" width="24" height="50" fill="none" stroke="none" pointer-events="all"/&gt;
&lt;path d="M 150 130 L 150 82.51 C 150 81.12 151.11 80 152.47 80 L 171.53 80 C 172.89 80 174 81.12 174 82.51 L 174 130 Z M 153.6 125.08 L 170.4 125.08 L 170.4 122.67 L 153.6 122.67 Z M 170.4 120.26 L 170.4 117.8 L 153.6 117.8 L 153.6 120.26 Z M 153.6 89.79 L 170.4 89.79 L 170.4 87.33 L 153.6 87.33 Z" fill="#00188d" stroke="none" pointer-events="all"/&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;/svg&gt;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
